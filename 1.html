<!DOCTYPE html>
<html>
<head>
  <style>
	  html, body {
	  height: 100%;
	  margin: 0;
	  }
	  #c {
	  width: 100%;
	  height: 100%;
	  display: block;
	  }
</style>
</head>
<body>
    <canvas id="c"></canvas>

    <script type="module">

    import * as THREE from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/build/three.module.js';
    import {OrbitControls} from 'https://threejsfundamentals.org/threejs/resources/threejs/r122/examples/jsm/controls/OrbitControls.js';
    import {GUI} from 'https://threejsfundamentals.org/threejs/../3rdparty/dat.gui.module.js';

    function main() {
      const canvas = document.querySelector('#c');
      const renderer = new THREE.WebGLRenderer({canvas});

      const fov = 75;
      const aspect = 2;  // the canvas default
      const near = 0.1;
      const camera = new THREE.PerspectiveCamera(fov, aspect, near);
      camera.position.y = 5;
      camera.position.z = 8;

      const controls = new OrbitControls(camera, canvas);
      controls.enableDamping = true;
      controls.target.set(0, 0, 0);
      controls.update();

      const gui = new GUI();

      const scene = new THREE.Scene();

      {
        const planeSize = 40;

        const loader = new THREE.TextureLoader();
        const texture = loader.load('https://threejsfundamentals.org/threejs/resources/images/checker.png');
        texture.wrapS = THREE.RepeatWrapping;
        texture.wrapT = THREE.RepeatWrapping;
        texture.magFilter = THREE.NearestFilter;
        const repeats = planeSize / 2;
        texture.repeat.set(repeats, repeats);

        const planeGeo = new THREE.PlaneBufferGeometry(planeSize, planeSize);
        const planeMat = new THREE.MeshPhongMaterial({
          map: texture,
          side: THREE.DoubleSide,
        });
        const mesh = new THREE.Mesh(planeGeo, planeMat);
        mesh.rotation.x = Math.PI * -.5;
        mesh.position.set(0, -3, 0)
        scene.add(mesh);
      }
      //{
      //  const color = 0xFFFFFF;
      //  const intensity = 1;
      //  const light = new THREE.DirectionalLight(color, intensity);
      //  const light2 = new THREE.DirectionalLight(color, intensity);
      //  light.position.set(-1, 2, 4);
      //  light2.position.set(1, -2, -4);
      //  scene.add(light);
      //  scene.add(light2);
      //}

      const boxWidth = 1;
      const boxHeight = 1;
      const boxDepth = 1;
      const geometry = new THREE.BoxGeometry(boxWidth, boxHeight, boxDepth);

      class ColorGUIHelper {
        constructor(object, prop) {
          this.object = object;
          this.prop = prop;
        }
        get value() {
          return `#${this.object[this.prop].getHexString()}`;
        }
        set value(hexString) {
          this.object[this.prop].set(hexString);
        }
      }

      {
        const color = 0xFFFFFF;
        const intensity = 1;
        const light = new THREE.PointLight(color, intensity);
        light.position.set(0, 2, 0);
        scene.add(light);

        const helper = new THREE.PointLightHelper(light);
        scene.add(helper);

        const folder = gui.addFolder("light");
        folder.addColor(new ColorGUIHelper(light, 'color'), 'value').name('color').onChange(requestRenderIfNotRequested);
        folder.add(light, 'intensity', 0, 2, 0.01).onChange(requestRenderIfNotRequested);
        folder.add(light, 'distance', 0, 40).onChange(requestRenderIfNotRequested);
        folder.add(light.position, 'x', -10, 10).onChange(requestRenderIfNotRequested);
        folder.add(light.position, 'y', 0, 10).onChange(requestRenderIfNotRequested);
        folder.add(light.position, 'z', -10, 10).onChange(requestRenderIfNotRequested);
        folder.open();
      }

      function makeInstance(geometry, color, x) {
        const material = new THREE.MeshPhongMaterial({color});

        const cube = new THREE.Mesh(geometry, material);
        scene.add(cube);

        cube.position.x = x;

        const folder = gui.addFolder(`Cube${x}`);
        folder.addColor(new ColorGUIHelper(material, 'color'), 'value')
            .name('color')
            .onChange(requestRenderIfNotRequested);
        folder.add(cube.scale, 'x', .1, 2)
            .name('scale x')
            .onChange(requestRenderIfNotRequested);
        folder.add(cube.scale, 'y', .1, 2)
            .name('scale y')
            .onChange(requestRenderIfNotRequested);
        folder.add(cube.scale, 'z', .1, 2)
            .name('scale z')
            .onChange(requestRenderIfNotRequested);
        folder.open();

        return cube;
      }

      makeInstance(geometry, 0x44aa88,  0);
      makeInstance(geometry, 0x8844aa, -2);
      makeInstance(geometry, 0xaa8844,  2);

      function resizeRendererToDisplaySize(renderer) {
        const canvas = renderer.domElement;
        const width = canvas.clientWidth;
        const height = canvas.clientHeight;
        const needResize = canvas.width !== width || canvas.height !== height;
        if (needResize) {
          renderer.setSize(width, height, false);
        }
        return needResize;
      }

      let renderRequested = false;

      function render() {
        renderRequested = undefined;

        if (resizeRendererToDisplaySize(renderer)) {
          const canvas = renderer.domElement;
          camera.aspect = canvas.clientWidth / canvas.clientHeight;
          camera.updateProjectionMatrix();
        }

        controls.update();
        renderer.render(scene, camera);
      }
      render();

      function requestRenderIfNotRequested() {
        if (!renderRequested) {
          renderRequested = true;
          requestAnimationFrame(render);
        }
      }

      controls.addEventListener('change', requestRenderIfNotRequested);
      window.addEventListener('resize', requestRenderIfNotRequested);
    }

    main();

    </script>
</body>
</html>
